// Parsing devicetree, this module is dependent on a subset libfdt
// Libfdt is dependent on the C stdlib, this dependency is replaced
// with fdt_stubs. The implementation of fdt_stubs can be found in
// libfdt/src/fdt_stubs.c
// The standard libfdt header file can be found here:
// https://github.com/dgibson/dtc/blob/main/libfdt/libfdt.h
// E.g., this is where fdt_path_offset(fdt, path) comes from

#include "libfdt.h"
#include "fdt.h"
#include "dtb.h"
#include "pl011.h"

// Return a set of addresses that can be mapped to PPN
// if return base_addr = 0 & size = 0, then most likely failure
/*
 * Note:
 * The DTB generated by QEMU does not include addr-cells and size-cells properties for the memory/ node.
 * Addr-cells and size-cells were both determined to be 2 by dumpting the DTB and looking at it's contents.
 * */
struct physical_memory get_physical_memory_node(uint64_t dtb_addr, struct pl011_ctx *ctx)
{
    const void  *fdt;                   // fdt base
    const char  *path;                  // full path to memory node
    int         offset;                 // offset from fdt base to memory node
    
    fdt =       (const void *)(uintptr_t)dtb_addr;
    path =      "/memory";
    offset =    fdt_path_offset(fdt, path);

    if (offset <= 0) {
        struct physical_memory not_found = { 0, 0 };
        return not_found;
    }

    int             len;                // length of reg property (in bytes)
    const char      *name;              // name of reg property
    const fdt32_t   *reg;               // pointer to reg
    
    name = "reg";
    reg = fdt_getprop(fdt, offset, name, &len);
    
    int             i;                  // iterator over cells
    uint64_t        mem_base_addr;
    uint64_t        mem_size;
    
    i = 0;
    mem_base_addr = 0;
    mem_size = 0;

    // addr cells come first in memory/ node reg
    // <addr_hi> <addr_low> <size_hi> <size_low>
    mem_base_addr = (uint64_t)fdt32_to_cpu(*(reg+i++));         // upper 32 bits
    mem_base_addr << 32;
    mem_base_addr = mem_base_addr | fdt32_to_cpu(*(reg+i++));   // lower 32 bits

    mem_size = (uint64_t)fdt32_to_cpu(*(reg+i++));
    mem_size << 32;
    mem_size = mem_size | fdt32_to_cpu(*(reg+i++));

    struct physical_memory ram = { mem_base_addr, mem_size };
    return ram;
}

// Returns 0 on success, else failure
int check_dtb_addr(uint64_t dtb_addr, struct pl011_ctx *ctx) {
    const void *fdt;
    fdt = (const void *)(uintptr_t)dtb_addr;
    
    //uint32_t raw = *(volatile const uint32_t *)fdt;
    //uint32_t magic = __builtin_bswap32(raw);            // expect 0xd00dfeed
    //pl011_puts("\nMagic number should be 0xd00dfeed", ctx);
    //pl011_puts("\nMagic number is = ", ctx);
    //pl011_put_hex((uint64_t)magic, ctx);

    int res;
    res = fdt_check_header(fdt);
    
    //if (res != 0) {
        //pl011_puts("\nInvalid DTB; Error Code: ", ctx);
        //pl011_put_hex((uint64_t)res, ctx);
        //pl011_puts("\n", ctx);
        //return res;
    //}
    //pl011_puts("\nValid DTB\n", ctx);

    return res;
}

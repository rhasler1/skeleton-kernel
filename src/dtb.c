// Parsing devicetree, this module is dependent on a subset libfdt
// Libfdt is dependent on the C stdlib, this dependency is replaced
// with fdt_stubs. The implementation of fdt_stubs can be found in
// libfdt/src/fdt_stubs.c
// The standard libfdt header file can be found here:
// https://github.com/dgibson/dtc/blob/main/libfdt/libfdt.h
// E.g., this is where fdt_path_offset(fdt, path) comes from

#include "libfdt.h"
#include "fdt.h"
#include "dtb.h"
#include "pl011.h"

// Return a set of addresses that can be mapped to PPN
// if return base_addr = 0 & size = 0, then most likely failure
/*
 * Note:
 * The DTB generated by QEMU does not include addr-cells and size-cells properties for the memory/ node.
 * Addr-cells and size-cells were both determined to be 2 by dumpting the DTB and looking at it's contents.
 * */
struct ram_ctx get_ram_ctx(uint64_t dtb_addr)
{
    const void  *fdt;                   // fdt base
    const char  *path;                  // full path to memory node
    int         offset;                 // offset from fdt base to memory node
    
    fdt =       (const void *)(uintptr_t)dtb_addr;
    path =      "/memory";
    offset =    fdt_path_offset(fdt, path);

    if (offset <= 0) {
        struct ram_ctx not_found = { 0, 0 };
        return not_found;
    }

    int             len;                // length of reg property (in bytes)
    const char      *name;              // name of reg property
    const fdt32_t   *reg;               // pointer to reg
    
    name = "reg";
    reg = fdt_getprop(fdt, offset, name, &len);
    
    int             i;                  // iterator over cells
    uint64_t        mem_base_addr;
    uint64_t        mem_size;
    
    i = 0;
    mem_base_addr = 0;
    mem_size = 0;

    // addr cells come first in memory/ node reg
    // <addr_hi> <addr_low> <size_hi> <size_low>
    mem_base_addr = (uint64_t)fdt32_to_cpu(*(reg+i++));         // upper 32 bits
    mem_base_addr << 32;
    mem_base_addr = mem_base_addr | fdt32_to_cpu(*(reg+i++));   // lower 32 bits

    mem_size = (uint64_t)fdt32_to_cpu(*(reg+i++));
    mem_size << 32;
    mem_size = mem_size | fdt32_to_cpu(*(reg+i++));

    struct ram_ctx ram = { mem_base_addr, mem_size };
    return ram;
}

// Returns 0 on success, else failure
int dtb_check_header(uint64_t dtb_addr) {
    const void *fdt;
    int res;

    fdt = (const void *)(uintptr_t)dtb_addr;
    res = fdt_check_header(fdt);

    return res;
}
